<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EDGERACE - NES Racing Game</title>
    <style>
        * {
            box-sizing: border-box;
            touch-action: manipulation;
        }

        body {
            margin: 0;
            padding: 10px;
            background: #1a1a2e;
            font-family: 'Segoe UI', Arial, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #eee;
        }

        h1 {
            color: #e94560;
            margin: 10px 0;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }

        #nes-canvas {
            width: 100%;
            max-width: 512px;
            aspect-ratio: 256 / 240;
            background: #000;
            border: 4px solid #333;
            border-radius: 8px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            padding: 20px 10px;
            gap: 20px;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* D-Pad */
        .dpad-container {
            position: relative;
            width: 130px;
            height: 130px;
        }

        .dpad-btn {
            position: absolute;
            width: 45px;
            height: 45px;
            background: linear-gradient(145deg, #3a3a5a, #2a2a4a);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #aaa;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            transition: all 0.1s;
        }

        .dpad-btn:active, .dpad-btn.pressed {
            background: linear-gradient(145deg, #e94560, #c73e54);
            border-color: #ff6b6b;
            color: #fff;
            transform: scale(0.95);
        }

        .dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
        .dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        .dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
        .dpad-right { right: 0; top: 50%; transform: translateY(-50%); }

        .dpad-up:active, .dpad-up.pressed { transform: translateX(-50%) scale(0.95); }
        .dpad-down:active, .dpad-down.pressed { transform: translateX(-50%) scale(0.95); }
        .dpad-left:active, .dpad-left.pressed { transform: translateY(-50%) scale(0.95); }
        .dpad-right:active, .dpad-right.pressed { transform: translateY(-50%) scale(0.95); }

        /* Action buttons */
        .action-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .action-row {
            display: flex;
            gap: 15px;
        }

        .action-btn {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: linear-gradient(145deg, #3a3a5a, #2a2a4a);
            border: 3px solid #555;
            color: #aaa;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            transition: all 0.1s;
        }

        .action-btn:active, .action-btn.pressed {
            background: linear-gradient(145deg, #e94560, #c73e54);
            border-color: #ff6b6b;
            color: #fff;
            transform: scale(0.95);
        }

        .start-select-row {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .small-btn {
            width: 60px;
            height: 30px;
            border-radius: 15px;
            background: linear-gradient(145deg, #3a3a5a, #2a2a4a);
            border: 2px solid #555;
            color: #aaa;
            font-size: 11px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .small-btn:active, .small-btn.pressed {
            background: linear-gradient(145deg, #e94560, #c73e54);
            border-color: #ff6b6b;
            color: #fff;
        }

        #status {
            margin-top: 10px;
            padding: 10px;
            background: #2a2a4a;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
        }

        .loading {
            color: #ffd93d;
        }

        .ready {
            color: #6bcb77;
        }

        .error {
            color: #ff6b6b;
        }

        /* Desktop keyboard hint */
        #keyboard-hint {
            margin-top: 15px;
            padding: 10px;
            background: #2a2a4a;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
            color: #888;
        }

        @media (min-width: 768px) {
            #controls {
                opacity: 0.3;
            }
            #controls:hover {
                opacity: 1;
            }
        }

        @media (max-width: 400px) {
            .dpad-container {
                width: 110px;
                height: 110px;
            }
            .dpad-btn {
                width: 38px;
                height: 38px;
                font-size: 16px;
            }
            .action-btn {
                width: 48px;
                height: 48px;
                font-size: 14px;
            }
        }

        #save-controls {
            margin-top: 15px;
            text-align: center;
        }

        #reset-save-btn {
            padding: 8px 16px;
            background: linear-gradient(145deg, #4a4a6a, #3a3a5a);
            border: 2px solid #666;
            border-radius: 5px;
            color: #ccc;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #reset-save-btn:hover {
            background: linear-gradient(145deg, #6a4a4a, #5a3a3a);
            border-color: #ff6b6b;
            color: #fff;
        }

        #reset-save-btn:active {
            transform: scale(0.95);
        }

        #screenshot-btn {
            padding: 8px 16px;
            background: linear-gradient(145deg, #4a6a4a, #3a5a3a);
            border: 2px solid #666;
            border-radius: 5px;
            color: #ccc;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 10px;
        }

        #screenshot-btn:hover {
            background: linear-gradient(145deg, #5a8a5a, #4a7a4a);
            border-color: #6bff6b;
            color: #fff;
        }

        #screenshot-btn:active {
            transform: scale(0.95);
        }

        #share-x-btn {
            padding: 8px 16px;
            background: linear-gradient(145deg, #4a4a6a, #3a3a5a);
            border: 2px solid #666;
            border-radius: 5px;
            color: #ccc;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 10px;
        }

        #share-x-btn:hover {
            background: linear-gradient(145deg, #2f7cff, #245fcc);
            border-color: #7fb3ff;
            color: #fff;
        }

        #share-x-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <h1>EDGERACE</h1>

    <div id="game-container">
        <canvas id="nes-canvas" width="256" height="240"></canvas>

        <div id="controls">
            <!-- D-Pad -->
            <div class="dpad-container">
                <button class="dpad-btn dpad-up" data-key="up">&#9650;</button>
                <button class="dpad-btn dpad-down" data-key="down">&#9660;</button>
                <button class="dpad-btn dpad-left" data-key="left">&#9664;</button>
                <button class="dpad-btn dpad-right" data-key="right">&#9654;</button>
            </div>

            <!-- Action buttons -->
            <div class="action-container">
                <div class="action-row">
                    <button class="action-btn" data-key="b">B</button>
                    <button class="action-btn" data-key="a">A</button>
                </div>
                <div class="start-select-row">
                    <button class="small-btn" data-key="select">SELECT</button>
                    <button class="small-btn" data-key="start">START</button>
                </div>
            </div>
        </div>

        <div id="status" class="loading">Loading emulator...</div>

        <div id="keyboard-hint">
            Keyboard: Arrow keys / WASD = D-Pad, Z = A, X = B, Enter = Start, Shift = Select<br>
            Gamepad: D-Pad/Stick, A/B buttons, Start/Select supported
        </div>

        <div id="save-controls">
            <button id="reset-save-btn">Reset Save Data</button>
            <button id="screenshot-btn">ðŸ“· Screenshot</button>
            <button id="share-x-btn">Share on X</button>
        </div>
    </div>

    <script src="https://unpkg.com/jsnes@1.2.1/dist/jsnes.min.js"></script>
    <script>
        // NES Emulator setup
        const canvas = document.getElementById('nes-canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');

        // Create ImageData for rendering
        const imageData = ctx.createImageData(256, 240);

        // Audio context
        let audioCtx = null;
        let scriptNode = null;
        const audioBuffer = [];
        const AUDIO_BUFFER_SIZE = 8192;

        // Create JSNES emulator
        const nes = new jsnes.NES({
            onFrame: function(frameBuffer) {
                // Convert frame buffer to ImageData
                for (let i = 0; i < frameBuffer.length; i++) {
                    const pixel = frameBuffer[i];
                    const j = i * 4;
                    imageData.data[j] = pixel & 0xFF;           // R
                    imageData.data[j + 1] = (pixel >> 8) & 0xFF;  // G
                    imageData.data[j + 2] = (pixel >> 16) & 0xFF; // B
                    imageData.data[j + 3] = 0xFF;                 // A
                }
                ctx.putImageData(imageData, 0, 0);
            },
            onAudioSample: function(left, right) {
                if (audioBuffer.length < AUDIO_BUFFER_SIZE) {
                    audioBuffer.push(left);
                    audioBuffer.push(right);
                }
            }
        });

        // Initialize audio
        function initAudio() {
            if (audioCtx) {
                // Resume if suspended (browser autoplay policy)
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                return;
            }

            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 44100
                });

                // Resume immediately (for browsers that start suspended)
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                scriptNode = audioCtx.createScriptProcessor(2048, 0, 2);
                scriptNode.onaudioprocess = function(e) {
                    const left = e.outputBuffer.getChannelData(0);
                    const right = e.outputBuffer.getChannelData(1);
                    for (let i = 0; i < left.length; i++) {
                        if (audioBuffer.length >= 2) {
                            left[i] = audioBuffer.shift();
                            right[i] = audioBuffer.shift();
                        } else {
                            left[i] = 0;
                            right[i] = 0;
                        }
                    }
                };
                scriptNode.connect(audioCtx.destination);
                console.log('Audio initialized, state:', audioCtx.state);
            } catch (err) {
                console.error('Audio init error:', err);
            }
        }

        // Key mapping (Arrow keys and WASD)
        const keyMap = {
            'ArrowUp': jsnes.Controller.BUTTON_UP,
            'ArrowDown': jsnes.Controller.BUTTON_DOWN,
            'ArrowLeft': jsnes.Controller.BUTTON_LEFT,
            'ArrowRight': jsnes.Controller.BUTTON_RIGHT,
            'KeyW': jsnes.Controller.BUTTON_UP,
            'KeyS': jsnes.Controller.BUTTON_DOWN,
            'KeyA': jsnes.Controller.BUTTON_LEFT,
            'KeyD': jsnes.Controller.BUTTON_RIGHT,
            'KeyZ': jsnes.Controller.BUTTON_A,
            'KeyX': jsnes.Controller.BUTTON_B,
            'Enter': jsnes.Controller.BUTTON_START,
            'ShiftRight': jsnes.Controller.BUTTON_SELECT,
            'ShiftLeft': jsnes.Controller.BUTTON_SELECT
        };

        // Touch button mapping
        const buttonMap = {
            'up': jsnes.Controller.BUTTON_UP,
            'down': jsnes.Controller.BUTTON_DOWN,
            'left': jsnes.Controller.BUTTON_LEFT,
            'right': jsnes.Controller.BUTTON_RIGHT,
            'a': jsnes.Controller.BUTTON_A,
            'b': jsnes.Controller.BUTTON_B,
            'start': jsnes.Controller.BUTTON_START,
            'select': jsnes.Controller.BUTTON_SELECT
        };

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            initAudio();
            const button = keyMap[e.code];
            if (button !== undefined) {
                nes.buttonDown(1, button);
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            const button = keyMap[e.code];
            if (button !== undefined) {
                nes.buttonUp(1, button);
                e.preventDefault();
            }
        });

        // Touch events for virtual pad
        function handleTouchStart(e) {
            e.preventDefault();
            initAudio();
            const btn = e.target.closest('[data-key]');
            if (btn) {
                const key = btn.dataset.key;
                const button = buttonMap[key];
                if (button !== undefined) {
                    nes.buttonDown(1, button);
                    btn.classList.add('pressed');
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            const btn = e.target.closest('[data-key]');
            if (btn) {
                const key = btn.dataset.key;
                const button = buttonMap[key];
                if (button !== undefined) {
                    nes.buttonUp(1, button);
                    btn.classList.remove('pressed');
                }
            }
        }

        // Add touch listeners to all buttons
        document.querySelectorAll('[data-key]').forEach(btn => {
            btn.addEventListener('touchstart', handleTouchStart, { passive: false });
            btn.addEventListener('touchend', handleTouchEnd, { passive: false });
            btn.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            // Prevent context menu on long press (mobile)
            btn.addEventListener('contextmenu', (e) => e.preventDefault());

            // Mouse support for testing on desktop
            btn.addEventListener('mousedown', (e) => {
                initAudio();
                const key = btn.dataset.key;
                const button = buttonMap[key];
                if (button !== undefined) {
                    nes.buttonDown(1, button);
                    btn.classList.add('pressed');
                }
            });
            btn.addEventListener('mouseup', (e) => {
                const key = btn.dataset.key;
                const button = buttonMap[key];
                if (button !== undefined) {
                    nes.buttonUp(1, button);
                    btn.classList.remove('pressed');
                }
            });
            btn.addEventListener('mouseleave', (e) => {
                const key = btn.dataset.key;
                const button = buttonMap[key];
                if (button !== undefined) {
                    nes.buttonUp(1, button);
                    btn.classList.remove('pressed');
                }
            });
        });

        // Prevent context menu on controls container (for long press on mobile)
        document.getElementById('controls').addEventListener('contextmenu', (e) => e.preventDefault());

        // SRAM persistence functions
        const SRAM_KEY = 'edgerace_nes_sram';
        const SRAM_START = 0x6000;
        const SRAM_SIZE = 0x2000;  // 8KB
        const SAVE_MAGIC = 0x52;
        const HIGH_SCORE_LOW_OFFSET = 1;   // high_scores[0] low 16-bit
        const HIGH_SCORE_HIGH_OFFSET = 7;  // high_scores_high[0] high 16-bit
        const GAME_NAME = 'EDGERACE';
        const SHARE_HASHTAGS = 'EDGERACE';

        function saveSRAM() {
            try {
                const sram = new Uint8Array(SRAM_SIZE);
                for (let i = 0; i < SRAM_SIZE; i++) {
                    sram[i] = nes.cpu.mem[SRAM_START + i] || 0;
                }
                const base64 = btoa(String.fromCharCode.apply(null, sram));
                localStorage.setItem(SRAM_KEY, base64);
            } catch (e) {
                console.warn('Failed to save SRAM:', e);
            }
        }

        function loadSRAM() {
            try {
                const base64 = localStorage.getItem(SRAM_KEY);
                if (base64) {
                    const binary = atob(base64);
                    for (let i = 0; i < binary.length && i < SRAM_SIZE; i++) {
                        nes.cpu.mem[SRAM_START + i] = binary.charCodeAt(i);
                    }
                    console.log('SRAM loaded from localStorage');
                    return true;
                }
            } catch (e) {
                console.warn('Failed to load SRAM:', e);
            }
            return false;
        }

        // Auto-save SRAM periodically (every 5 seconds)
        setInterval(saveSRAM, 5000);

        // Save on page unload
        window.addEventListener('beforeunload', saveSRAM);

        // Reset SRAM (clear save data)
        function resetSRAM() {
            if (!confirm('Are you sure you want to reset all save data?\n(High scores and unlocked loops will be lost)')) {
                return;
            }
            try {
                // Clear localStorage
                localStorage.removeItem(SRAM_KEY);
                // Clear NES memory
                for (let i = 0; i < SRAM_SIZE; i++) {
                    nes.cpu.mem[SRAM_START + i] = 0;
                }
                status.textContent = 'Save data reset! Refresh or restart game.';
                status.className = 'ready';
                console.log('SRAM reset complete');
            } catch (e) {
                console.error('Failed to reset SRAM:', e);
                status.textContent = 'Error resetting save data';
                status.className = 'error';
            }
        }

        // Attach reset button handler
        document.getElementById('reset-save-btn').addEventListener('click', resetSRAM);

        function readUint16LE(address) {
            const lo = nes.cpu.mem[address] || 0;
            const hi = nes.cpu.mem[address + 1] || 0;
            return (hi << 8) | lo;
        }

        function readHighScoreFromSRAM() {
            const magic = nes.cpu.mem[SRAM_START] || 0;
            if (magic !== SAVE_MAGIC) {
                return 0;
            }
            // Read 32-bit score (low 16-bit + high 16-bit)
            const low = readUint16LE(SRAM_START + HIGH_SCORE_LOW_OFFSET);
            const high = readUint16LE(SRAM_START + HIGH_SCORE_HIGH_OFFSET);
            return (high * 65536) + low;
        }

        function openShareIntent() {
            const score = readHighScoreFromSRAM();
            const text = `${GAME_NAME} ãƒã‚¤ã‚¹ã‚³ã‚¢: ${score}`;
            const url = window.location.href;
            const params = new URLSearchParams({
                text,
                url,
                hashtags: SHARE_HASHTAGS
            });
            const intentUrl = `https://twitter.com/intent/tweet?${params.toString()}`;
            window.open(intentUrl, '_blank', 'noopener,noreferrer');
        }

        document.getElementById('share-x-btn').addEventListener('click', openShareIntent);

        // Screenshot function
        function takeScreenshot() {
            try {
                // Create a scaled-up canvas for better quality (2x)
                const scale = 2;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 256 * scale;
                tempCanvas.height = 240 * scale;
                const tempCtx = tempCanvas.getContext('2d');

                // Disable image smoothing for crisp pixels
                tempCtx.imageSmoothingEnabled = false;

                // Draw the NES canvas scaled up
                tempCtx.drawImage(canvas, 0, 0, 256 * scale, 240 * scale);

                // Generate filename with timestamp
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const filename = `edgerace-${timestamp}.png`;

                // Create download link
                const link = document.createElement('a');
                link.download = filename;
                link.href = tempCanvas.toDataURL('image/png');
                link.click();

                status.textContent = 'Screenshot saved: ' + filename;
                status.className = 'ready';
            } catch (err) {
                console.error('Screenshot failed:', err);
                status.textContent = 'Screenshot failed';
                status.className = 'error';
            }
        }

        // Attach screenshot button handler
        document.getElementById('screenshot-btn').addEventListener('click', takeScreenshot);

        // Gamepad support
        let gamepadIndex = null;
        const gamepadState = {};

        window.addEventListener('gamepadconnected', (e) => {
            console.log('Gamepad connected:', e.gamepad.id);
            gamepadIndex = e.gamepad.index;
            status.textContent = 'Gamepad connected: ' + e.gamepad.id.substring(0, 30);
            status.className = 'ready';
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log('Gamepad disconnected');
            if (gamepadIndex === e.gamepad.index) {
                gamepadIndex = null;
            }
        });

        function pollGamepad() {
            if (gamepadIndex === null) return;

            const gamepads = navigator.getGamepads();
            const gp = gamepads[gamepadIndex];
            if (!gp) return;

            initAudio();

            // D-pad (buttons 12-15 or axes)
            const up = gp.buttons[12]?.pressed || gp.axes[1] < -0.5;
            const down = gp.buttons[13]?.pressed || gp.axes[1] > 0.5;
            const left = gp.buttons[14]?.pressed || gp.axes[0] < -0.5;
            const right = gp.buttons[15]?.pressed || gp.axes[0] > 0.5;

            // Face buttons (standard mapping: 0=B, 1=A, 2=Y, 3=X on Xbox style)
            // NES: A=east, B=south. Map button 0 to B, button 1 to A
            const btnA = gp.buttons[1]?.pressed || gp.buttons[0]?.pressed;
            const btnB = gp.buttons[2]?.pressed || gp.buttons[3]?.pressed;
            const btnStart = gp.buttons[9]?.pressed;
            const btnSelect = gp.buttons[8]?.pressed;

            // Update button states
            function updateButton(name, pressed, nesButton) {
                if (pressed && !gamepadState[name]) {
                    nes.buttonDown(1, nesButton);
                } else if (!pressed && gamepadState[name]) {
                    nes.buttonUp(1, nesButton);
                }
                gamepadState[name] = pressed;
            }

            updateButton('up', up, jsnes.Controller.BUTTON_UP);
            updateButton('down', down, jsnes.Controller.BUTTON_DOWN);
            updateButton('left', left, jsnes.Controller.BUTTON_LEFT);
            updateButton('right', right, jsnes.Controller.BUTTON_RIGHT);
            updateButton('a', btnA, jsnes.Controller.BUTTON_A);
            updateButton('b', btnB, jsnes.Controller.BUTTON_B);
            updateButton('start', btnStart, jsnes.Controller.BUTTON_START);
            updateButton('select', btnSelect, jsnes.Controller.BUTTON_SELECT);
        }

        // Load ROM
        async function loadROM() {
            try {
                status.textContent = 'Loading ROM...';
                status.className = 'loading';

                const response = await fetch('./edgerace.nes?v=' + Date.now());
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const arrayBuffer = await response.arrayBuffer();
                const romData = new Uint8Array(arrayBuffer);

                // Convert to string for JSNES
                let romString = '';
                for (let i = 0; i < romData.length; i++) {
                    romString += String.fromCharCode(romData[i]);
                }

                nes.loadROM(romString);

                // Load saved SRAM after ROM is loaded
                loadSRAM();

                status.textContent = 'Ready! Press START to play';
                status.className = 'ready';

                // Start emulation loop (locked to 60 FPS like real NES)
                const FRAME_TIME = 1000 / 60;  // ~16.67ms per frame
                let lastFrameTime = 0;

                function frame(currentTime) {
                    requestAnimationFrame(frame);

                    // Limit to 60 FPS
                    if (currentTime - lastFrameTime < FRAME_TIME) {
                        return;
                    }
                    lastFrameTime = currentTime - ((currentTime - lastFrameTime) % FRAME_TIME);

                    // Poll gamepad input
                    pollGamepad();

                    nes.frame();
                }
                requestAnimationFrame(frame);

            } catch (err) {
                status.textContent = 'Error loading ROM: ' + err.message;
                status.className = 'error';
                console.error('ROM load error:', err);
            }
        }

        // Start loading
        loadROM();
    </script>
</body>
</html>
